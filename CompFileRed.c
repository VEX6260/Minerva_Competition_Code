#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  claw_encoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,            ,             tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           left_motor_1,  tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left_motor_2,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           right_motor_1, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           right_motor_2, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           shooting,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           claw_motor,    tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port8,           left_lift_motor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           right_lift_motor, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//1530 max encoder height negative
//
//PARAMETERS
//1st param is the starting auton position
//P - POLE POSITION
//F - FLAG POSITION
//2nd param is the ending auton position
//L - CLOSET FLAG POLE TO STARTING AUTON POSITION
//S - PARKING SPOT
//ending param
//T - RELATIVE TO TIME
//E - RELATIVE TO AN ENCODER
//G - RELATIVE TO A GYROSCOPE
//A - RELATIVE TO AN ACCELEROMETER
//ending final
//N - full speed, normal
//
//AUTON DEFINTION 1ST GENERATION
#define AUTON_FUNC_6260FLTN 60
#define AUTON_FUNC_6260PSTN 60
#define AUTON_FUNC_6260FSTN 60

//AUTON DEFINITION 2ND GENERATION
#define AUTON_FUNC_6260STN 60

//AUTON DEFINITION ANGLE TABLE
#define AUTON_FUNC_6260A90TN 60
#define AUTON_FUNC_6260A45TN 60

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//CLASSES START
typedef enum {
	RIGHT, LEFT
} Direction;

typedef struct auton_func_62603_ {
	int b0;
	int b1;
	int b2;
} auton_func_62603a;
//CLASSES END

int dynamic_lift_height = 99999;

//drive control functions
void turnAt(int degrees);
void stopMotors();
int encoderTicks(int inches);
void move(int inches);
void moveLeft(int speed);
void moveRight(int speed);
void liftControl(int speed, bool up);
void clawControl(int speed);
void dynamicLiftControl(int speed);
void turnControl(int speed);
void tankDrive(int arg0, int arg1);
void slowDrive(int up, int down, int m_left, int m_right, int speed);
void setUp();
void moveForward(int speed);
void turnLeft(int speed);
void turnRight(int speed);

//auton funcs...
void auton_func_62601();
void auton_func_62602(bool b0);
void auton_func_62603(auton_func_62603a args);

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

  SensorType[in4] = sensorGyro;
	sensorvalue[in1] = 0;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
	//mapEncoderToMotor(left_lift_motor, left_lift_encoder);
	//mapEncoderToMotor(left_motor_1, left_motor_1_encoder);
	//mapEncoderToMotor(right_motor_1, right_motor_1_encoder);
	//mapEncoderToMotor(claw_motor, claw_encoder);
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
  // ..........................................................................
  // Insert user code here.
  // ..........................................................................

  // Remove this function call once you have "real" code.
  //AutonomousCodePlaceholderForTesting();

	//afa instantiation
	auton_func_62603a afa;
	afa.b0 = true;
	afa.b1 = false;
	afa.b2 = false;

	//auton_func_62601();
	//wait1Msec(5000);
	auton_func_62602(true);
	//auton_func_62603(afa);
}

//move forward command
void moveForward(int speed) {
		moveLeft(speed);
		moveRight(speed);
}

void turnLeft(int speed) {
	moveLeft(-speed);
	moveRight(speed);
}

void turnRight(int speed) {
	moveLeft(speed);
	moveRight(-speed);
}

/**
* -----------------------------------
*   DRIVE FORWARD AND HIT THE FLAG
* -----------------------------------
*/
void auton_func_62601() {
	moveLeft(127);
	moveRight(127);
	wait1Msec(4000);
	stopMotors();
}

/**
* -----------------------------------
*  TURN AND PARK RED / BLUE INVERSE
* -----------------------------------
*/
//b0 = true if red
void auton_func_62602(bool b0) {
  moveLeft(-127);
	moveRight(-127);
	wait1Msec(3000);
	//blue
	if (!b0) {
			moveLeft(-127);
			moveRight(127);
	}

	//red
	if (b0) {
			moveLeft(127);
			moveRight(-127);
			}

	wait1Msec(550);
	//while (sensorvalue[in1] < 90) {

	//}
	stopMotors();
	wait1Msec(500);
	moveLeft(127);
	moveRight(127);
	wait1Msec(550);
	motor[left_lift_motor]  = -127;
	motor[right_lift_motor]  = -127;
	wait1Msec(2500);
	stopMotors();
}

/**
* -----------------------------------
*     HIT THE FLAG AND THEN PARK
* -----------------------------------
*/
void auton_func_62603(auton_func_62603a args) {
		if (args.b0) {
			moveForward(127);
			wait1Msec(AUTON_FUNC_6260FSTN);
			stopMotors();
		}

		if (args.b1) {
			moveForward(-127);
			wait1Msec(AUTON_FUNC_6260FSTN);
			stopMotors();
		}

		if (args.b2) {
			turnRight(127);
			wait1Msec(AUTON_FUNC_6260A90TN);
			stopMotors();
			moveForward(127);
			wait1Msec(AUTON_FUNC_6260STN);
			stopMotors();
		}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

void move(int inches) {
		//proportionality constant
	float kp = 0.2;

	while (abs(nMotorEncoder[left_motor_1]) < encoderTicks(inches)) {
			int error = abs(nMotorEncoder[left_motor_1]) - encoderTicks(inches);
			moveLeft(error * kp);
			moveRight(error * kp);
			if (abs(nMotorEncoder[left_motor_1]) < encoderTicks(inches - 1))
				break;
	}
}

void moveRight(int speed) {
		motor[right_motor_1] = -speed;
		motor[right_motor_2] = -speed;
}

void moveLeft(int speed) {
		motor[left_motor_1] = speed;
		motor[left_motor_2] = speed;
}

int encoderTicks(int inches) {
	int ticks = ((inches * -1) / 12.56) * 627.2;
	return ticks/2;
}

task lcdScreen()
{
	bLCDBacklight = true;									// Turn on LCD Backlight
	string mainBattery, backupBattery;

	while(true)														// An infinite loop to keep the program running until you terminate it
	{
		clearLCDLine(0);											// Clear line 1 (0) of the LCD
		clearLCDLine(1);											// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Primary: ");
		sprintf(mainBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0,'V'); //Build the value to be displayed
		displayNextLCDString(mainBattery);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "Backup: ");
		sprintf(backupBattery, "%1.2f%c", BackupBatteryLevel/1000.0, 'V');	//Build the value to be displayed
		displayNextLCDString(backupBattery);

		//Short delay for the LCD refresh rate
		wait1Msec(100);
	}
}

task liftStable() {
	/*int encoder_height    = 100;
	int tmp_height_buffer = 10;
	while (true) {
			bool button = !vexRT[Btn6U] && !vexRT[Btn6D];

			if (nMotorEncoder[left_lift_motor] > encoder_height + tmp_height_buffer && button) {
					motor[right_lift_motor] = -25;
					motor[left_lift_motor]  = -25;
			}

			if (nMotorEncoder[left_lift_motor] < encoder_height + tmp_height_buffer && button) {
					motor[right_lift_motor] = 25;
					motor[left_lift_motor]  = 25;
			}
	}*/
}

task usercontrol()
{
	startTask(lcdScreen);
	startTask(liftStable);
  // User control code here, inside the loop
	SensorValue[claw_encoder] = 0;
	SensorType[in4] = sensorGyro;
	sensorvalue[in1] = 0;

		//blue
	/*if (true) {
			moveLeft(-127);
			moveRight(127);
	}

	//red
	if (false) {
			moveLeft(127);
			moveRight(-127);
	}

	wait1Msec(445);
	//while (sensorvalue[in1] < 90) {

	//}
	stopMotors();*/

//auton_func_62602(true);
  while (true)
  {
    // This is the main execution loop for the user control program.
    // Each time through the loop your program should update motor + servo
    // values based on feedback from the joysticks.

    // ........................................................................
    // Insert user code here. This is where you use the joystick values to
    // update your motors, etc.
    // ........................................................................

    // Remove this function call once you have "real" code.
    //UserControlCodePlaceholderForTesting();
  	tankDrive(vexRT[Ch4], vexRT[Ch2]);
		//tankDrive(vexRT[Ch4], vexRT[Ch2]);
		slowDrive(vexRT[Btn7U], vexRT[Btn7D], vexRT[Btn7L], vexRT[Btn7R], 35);
		//slowDrive(vexRT[Btn7U], vexRT[Btn7D], vexRT[Btn7L], vexRT[Btn7R], 35);
		//liftControl(127);
		dynamicLiftControl(127);
		clawControl(40);
	/*	if (vexRT[Btn8L]) {
			setUp();
		}
		if (vexRT[Btn8R]) stopMotors();

		///writeDebugStream("%d \n", SensorValue[claw_encoder]);
		//motor[claw_motor] = 28;
	//if (vexRT[Btn8U]) {
		//motor[claw_motor] = speed
		//if (vexRT[Btn5U]) {
		  //SensorValue[claw_encoder] = 0;
		  //while (SensorValue[claw_encoder] < 90) {
		  //	motor[claw_motor] = 28;
		 // }
		  //motor[claw_motor] = 0;
	SensorValue[claw_encoder] = 0;
	while (SensorValue[claw_encoder] < 1680) {
		motor[claw_motor] = 127;
		//}
		motor[claw_motor] = 0;*/
}

	//if (vexRT[Btn5D]) {
	 // SensorValue[claw_encoder] = 0;
	  //while (SensorValue[claw_encoder] < 88) {
	  	//motor[claw_motor] = 28;
	  //}
	  //motor[claw_motor] = 0;
	//}
		/*if (vexRT[Btn8U]) {
			motor[claw_motor] = 25;
			wait1Msec(1000);
			motor[claw_motor]  = 0;
		}

		if (vexRT[Btn8D]) {
			motor[claw_motor] = 25;
			wait1Msec(500);
			motor[claw_motor]  = 0;
		}*/
  }



void setUp() {
	if (vexRT[Btn8R]) { stopMotors(); return; }
	motor[right_lift_motor] = -127;
	if (vexRT[Btn8R]) { stopMotors(); return; }
	motor[left_lift_motor]  = -127;
	if (vexRT[Btn8R]) { stopMotors(); return; }
	moveRight(127);
	if (vexRT[Btn8R]) { stopMotors(); return; }
	moveLeft(127);
	if (vexRT[Btn8R]) { stopMotors(); return; }
	wait1Msec(1000);
	if (vexRT[Btn8R]) { stopMotors(); return; }
	motor[right_lift_motor] = 60;
	if (vexRT[Btn8R] ) { stopMotors(); return; }
	motor[left_lift_motor]  = 60;
	if (vexRT[Btn8R]) { stopMotors(); return; }
	wait1Msec(250);
	if (vexRT[Btn8R]) { stopMotors(); return; }
	motor[right_lift_motor] = 0;
	if (vexRT[Btn8R] ) { stopMotors(); return; }
	motor[left_lift_motor]  = 0;
	if (vexRT[Btn8R]) { stopMotors(); return; }
	wait1Msec(2000);
	if (vexRT[Btn8R]) { stopMotors(); return; }
	stopMotors();
	if (vexRT[Btn8R]) { stopMotors(); return; }
	motor[right_lift_motor] = 0;
	if (vexRT[Btn8R]) { stopMotors(); return; }
	motor[left_lift_motor]  = 0;
	if (vexRT[Btn8R]) { stopMotors(); return; }
}

void slowDrive(int up, int down, int m_left, int m_right, int speed) {
	if (up) {
		moveLeft(speed);
		moveRight(speed);
	}

	if (down) {
		moveLeft(-speed);
		moveRight(-speed);
	}

	if (m_left) {
			moveLeft(-speed);
			moveRight(speed);
	}

	if (m_right) {
			moveLeft(speed);
			moveRight(-speed);
	}
}

void tankDrive(int arg0, int arg1) {
  motor[left_motor_1]  = arg0 + arg1;
  motor[right_motor_1] = arg0 - arg1;
  motor[left_motor_2]  = arg0 + arg1;
  motor[right_motor_2] = arg0 - arg1;
}

void turnControl(int speed) {
		moveRight(speed);
		moveLeft(-speed);
}

void dynamicLiftControl(int speed) {
		//if (vexRT[Btn8U] || vexRT[Btn8U]) {
		//		dynamic_lift_height = encoderTicks(nMotorEncoder[left_lift_motor]);
		//}
		//writeDebugStream("%d \n", encoderTicks(nMotorEncoder[left_lift_motor]));
		//if (vexRT[Btn8D] || vexRT[Btn8D]) {
		//		dynamic_lift_height = 999999;
		//}

		if (encoderTicks(nMotorEncoder[left_lift_motor]) < dynamic_lift_height) liftControl(speed, true);
		else liftControl(speed, false);
}

void clawControl(int speed) {
if (vexRT[Btn5U]) {
	motor[claw_motor] = speed;
	} else if (vexRT[Btn5D]) {
		motor[claw_motor] = -speed;
	} else {
		motor[claw_motor] = 0;
	}
	//writeDebugStreamLine("%d",nMotorEncoder[claw_encoder]);
	/*if (vexRT[Btn8U]) {
			nMotorEncoder[claw_motor] = 0;
			while (nMotorEncoder[claw_motor] < 360) {
					motor[claw_motor] = speed;
			}
			stopMotors();
			nMotorEncoder[claw_motor] = 0;
	}*/

	//Encoder Claw Control
	/*if (vexRT[Btn8U]) {
			while (nMotorEncoder[claw_encoder] < 500) {
					motor[claw_motor] = speed;
			}
			stopMotors();
			nMotorEncoder[claw_motor] = 0;
	}*/
}


void liftControl(int speed, bool up) {
	if ((vexRT[Btn6U])&& up) {
		motor[right_lift_motor] = speed;
		motor[left_lift_motor]  = speed;
	} else if (vexRT[Btn6D]) {
		motor[right_lift_motor] = -speed;
		motor[left_lift_motor]  = -speed;
	} else {
		motor[right_lift_motor] = 0;
		motor[left_lift_motor]  = 0;
	}

	/*if (vexRT[Btn8U]) {
		moveForward(-100);
		wait1Msec(350);
		motor[right_lift_motor] = -120;
		motor[left_lift_motor]  = -120;
		wait1Msec(250);
		motor[right_lift_motor] = 0;
		motor[left_lift_motor]  = 0;
		wait1Msec(250);
		stopMotors();
	}*/
}

void turn(Direction direction_enum) {
	int direction = direction_enum == RIGHT ? 1 : -1;

	while (abs(sensorvalue[in1]) / 10 < 90) {
			moveLeft(45 * direction);
			moveRight(-45 * direction);
	}

	stopMotors();
}

void turnAt(int degrees) {
		int direction = degrees > 0  ? 1 : -1;

		while (abs(sensorvalue[in1]) / 10 < degrees) {
			moveLeft(45 * direction);
			moveRight(-45 * direction);
		}

		stopMotors();
}

void stopMotors() {
	moveLeft(0);
	moveRight(0);
}
